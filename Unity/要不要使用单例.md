# 要不要使用单例
单例是一种设计模式，他非常的简单，单例就两个目的，一个是保证实现单例的类在全生命周期内只有一个，一个是保证任何一处代码都可以访问它。看一个一般语言的实现方式。

``` C#
public class SingletonExample
{
    static SingletonExample instance;

    public static SingletonExample GetInstance()
    {
        if (instance == null)
        {
            instance =  new SingletonExample();
            
        }
        
        return instance;
    }

    private SingletonExample()
    {
        // private constructor
    }

    public void Func()
    {
        // some logic
    }
}
```

回到Unity游戏开发中，我们首先要明确的是为什么会想到使用单例，他能解决我们的什么需求。一个常见的需求是，想要让一个GO在游戏生命周期中全局保持不变，比如一个负责游戏音乐和音效播放的GO。因为输出设备一般只有一个，所以全局使用一个GO负责，在不同场景中存在且唯一。这个需求很简单，在看完上面的一般的单例实现方式后，你是不是马上想到了可以用单例解决这个需求？这里介绍金锤子的概念。什么是金锤子，它被定义为一个可以解决某些特定问题的完美工具。当你对某一个工具非常熟悉的时候，它就成了你的金锤子，让你面对任何一个问题的时候，不管问题是什么，你都觉得可以用金锤子来解决，而忽视了这个问题是否真正属于金锤子适用的特定问题。这个比喻想要告诉大家的是，对待不同的问题，我们需要的是寻找解决这个问题的方法，而不是已有的最适合的解决方案。它跟我们这里聊到的单例有什么关系呢？单例作为一种设计模式，其实就是我们程序员掌握的一种工具。它因为如此的简单，以至于我们可以轻松的把它套在我们的问题上面。

先看一下在Unity里面使用单例实现上面的需求的代码。
```C#
public class AudioPlayer : MonoBehaviour
{
    public static AudioPlayer instance;

    void Awake()
    {
        if (instance == null)
        {
            instance = this;
            DontDestroyOnLoad(this);
        }
        else if (instance != null && instance != this)
        {
            Destroy(gameObject);
        }
    }

    public void FadeMusic()
    {
        // some logic
    }
}
```

这段代码存在什么问题呢？它做了两件事，一件事是负责实现单例，另一件事则是音乐播放的具体逻辑。这一点违反了我们一个类应该做一件事的原则。同时引入了不必要的功能，如全局可达。

那么应该怎么做更好呢，请看下面的代码

```C#
public class PersistentObjectSpawner : MonoBehaviour
{
    static bool hasSpawned = false;

    [SerializeField] GameObject persistentObjectPrefab;

    void Awake()
    {
        if (!hasSpawned)
        {
            SpawnPersistentObject();
            hasSpawned = true;
        }
    }

    void SpawnPersistentObject()
    {
        GameObject instance = Instantiate(persistentObjectPrefab);
        DontDestroyOnLoad(instance);
    }
}

public class AudioPlayer : Monobehaviour
{
    public void FadeMusic()
    {
        // some logic
    }
}
```
我们将两件事拆开，现在AudioPlayer只关心音乐播放的业务逻辑，通过PersistentObjectSpawner实现唯一性。

上面的两段代码可以看出：单例模式虽然可以方便地实现全局唯一和可访问性，但容易导致代码耦合度高、测试困难和全局状态泛滥。通过将职责拆分如使用PersistentObjectSpawner管理唯一性，AudioPlayer专注业务逻辑，可以提升代码的可维护性和复用性。