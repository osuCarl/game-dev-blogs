# 一个高内聚低耦合的例子
```C# 
// 先来看看坏代码
public class Player : Monobahaviour
{
    [SerializedField] Animator animator;
    [SerializedField] AudioSource audioSource;
    [SerializedField] AudioClip hitSound;
    [SerializedField] float health = 100f;

    public void KnockBack()
    {
        animator.SetTrigger("t_KnockBack");
    }

    public void TakeDamage()
    {
        health -= 10;
    }

    public void PlayHitSound()
    {
        audioSource.PlayOneShot(hitSound)
    }
}

public class Enemy : Monobehaviour
{
    Player player；
    
    void Start()
    {
        player = GameObject.FindObjectOfType<Player>()
    }

    void Update()
    {
        // if condition is met
        AttackPlayer();
    }

    public void AttackPlayer()
    {
        player.KnockBack()
        player.TakeDamage()
        player.PlayHitSound()
    }
}

// 这段代码实现了敌人攻击玩家的逻辑。
// Player 类定义了三个受到攻击的逻辑的方法，然后 Enemy 类 在 Start 中 Cache Player 引用。
// 最后通过调用 Player 类定义的三个受击相关函数实现攻击逻辑。
// 这段代码存在三个问题
// 一个是低内聚，Player 实现受击逻辑的时候，总共写了三个函数，如果其他的地方没有使用这些函数，那么你就不应该拆开他们。
// 一个问题是高耦合。Enemy 类执行攻击玩家的逻辑完全依赖 Player 类。更新 Player 的时候，也要更新 Enemy。
// 当你改变一处代码，发现自己不得不跟着修改其他很多处代码的时候，你就应该意识到你的代码存在高耦合的问题。
// 最后是可能存在Cache Invalidation，Enemy 类只在 Start 方法里获取 Player, 可能为null，指向玩家的引用可能发生改变，这里不多展开。

```

```C# 
// 可以通过接口进行解耦
public Interface IAttackable
{
    public void TakeHit();
}

public class Player : Monobahaviour, IAttackable
{
    [SerializedField] Animator animator;
    [SerializedField] AudioSource audioSource;
    [SerializedField] AudioClip hitSound;
    [SerializedField] float health = 100f;

    public void TakeHit()
    {
        animator.SetTrigger("t_KnockBack");
        health -= 10;
        audioSource.PlayOneShot(hitSound)
    }
}

public class Enemy : Monobehaviour
{
    void Update()
    {
        // if condition is met
        // find player as target
        Attack(target);
    }

    public void Attack(IAttackable target)
    {
        if (target != null)
        {
            target.TakeHit();
        }
    }
}

// 通过引入 IAttackable 接口，Player 类实现该接口，同时把受击相关逻辑放在一处，实现高内聚。
// Enemy 类现在持有的是一个 IAttackable 的引用，通过接口指定的方法执行攻击逻辑，不再关心 Player 类的具体实现，从而实现解耦。此外，只要是实现了该接口的类，都可以作为Enemy 的攻击对象，提高了代码拓展性。

```