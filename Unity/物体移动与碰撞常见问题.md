# Unity 物体移动与碰撞常见问题

**日期:** 2025-09-05
**作者:** @osuCarl
**Unity版本:** 2022.3.47f1

这篇笔记旨在总结 Unity 中处理物体移动，特别是涉及物理碰撞时的常见问题和实践。

---

## 1. 物体移动的两种主要方法

### 1.1. 直接操作 Transform

这是最直接的移动方式，通常在 `Update()` 中调用。

```csharp
// 示例：每秒沿Y轴移动 moveSpeed 个单位
public class Mover : Monobehaviour
{
    [SerializeField] float moveSpeed = 10f;

    void Update()
    {
        float moveAmount = Input.GetAxis("Vertical") * moveSpeed * Time.deltaTime;
        transform.Translate(0, moveAmount, 0);
    }
}
```

- **优点**: 简单、直观。
- **缺点**:
    - 它会**绕过物理引擎**。
    - 当物体带有 `Rigidbody` 组件时，直接修改 `transform` 会导致物理状态与视觉位置不一致，从而在碰撞时产生**抖动**或**穿透**。

### 1.2. 通过 Rigidbody 操作

这是与物理引擎交互的正确方式，所有操作建议放在 `FixedUpdate()` 中。

#### 方法 A: 设置速度 `Rigidbody.velocity`

直接给刚体一个持续的速度。

```csharp
public class Mover : Monobehaviour
{
    [SerializeField] float moveSpeed = 10f;
    
    Rigidbody _rb;

    // 推荐使用 Awake() 获取当前 GameObject 上组件的引用
    void Awake()
    {
        _rb = GetComponent<Rigidbody>();
    }

    void FixedUpdate()
    {
        // 获取移动量 moveAmount
        float moveAmount = Input.GetAxis("Vertical") * moveSpeed;
       
       // 注意：velocity 使用的是世界坐标系
        rb.velocity = new Vector3(0, moveAmount, 0);

        // 如果要使用局部坐标 (如和旋转结合，指定forward方向)，需要转换
        rb.velocity = transform.TransformDirection(new Vector3(0, moveAmount, 0)); 
    }
}

```

- **适用场景**: 需要物体保持恒定速度的场合，如子弹飞行。

#### 方法 B: 使用 `Rigidbody.MovePosition`

平滑地将刚体移动到目标位置，此时计算的位置增量需要乘以 Time.fixedDeltaTime。

```csharp
public class Mover : Monobehaviour
{
    [SerializeField] float moveSpeed = 10f;
    
    Rigidbody _rb;

    // 推荐使用 Awake() 获取当前 GameObject 上组件的引用
    void Awake()
    {
        _rb = GetComponent<Rigidbody>();
    }

    void FixedUpdate()
    {
        // 获取移动量 moveAmount，注意 Time.fixedDeltaTime 的使用
        float moveAmount = Input.GetAxis("Vertical") * moveSpeed * Time.fixedDeltaTime;
       
        Vector3 move = new Vector3(0, moveAmount, 0);
        rb.MovePosition(rb.position + move);
    }
}
```

- **适用场景**: 需要精确控制每帧移动的场合，效果类似 `transform.Translate`，但能正确处理物理交互，是解决抖动的首选方案。

---

## 2. 移动与碰撞中的常见问题

### 2.1. 碰撞失效（穿透现象）

一个细小的高速物体（如子弹）在撞向另一个物体时，直接穿了过去，没有触发碰撞。这是因为 Unity 默认的碰撞检测模式（`Collision Detection`）是 `Discrete`，它只在物理帧的精确时间点检测碰撞。如果物体在一帧内移动的距离超过了对方的厚度，就会“跳”过对方，导致检测失败。

### 2.2. 碰撞或移动中抖动

物体在与其他物体接触时，或者在移动过程中，出现不平滑的抖动。这是因为在 `Update()` 中使用 `transform.Translate` 移动带 `Rigidbody` 的物体，物理引擎在 `FixedUpdate()` 中修正位置，两者冲突导致抖动。另外，游戏渲染帧率（`Update`）与物理更新频率（`FixedUpdate`）不一致，导致视觉上物体位置更新不连续。

---

## 3. 解决方案与最佳实践

### 3.1. 始终使用 `Rigidbody` 移动物理对象

为了让物理引擎正确工作，放弃 `transform.Translate`，改用 `rb.velocity` 或 `rb.MovePosition`。

### 3.2. 在 `FixedUpdate` 中处理物理逻辑

将所有与 `Rigidbody` 相关的代码（移动、施加力等）都放在 `FixedUpdate()` 中，以保证与物理引擎的更新步调一致。

### 3.3. 开启连续碰撞检测（解决穿透）

对于高速移动的物体，必须修改其 `Rigidbody` 组件的 `Collision Detection` 属性：
- **`Continuous`**: Unity 会在物体的移动路径上进行扫描，确保不会错过任何碰撞。这是解决穿透问题的关键。

### 3.4. 开启插值（解决视觉抖动）

为了让高帧率下的移动看起来更平滑，修改 `Rigidbody` 组件的 `Interpolate` 属性：
- **`None`**: 默认值，不进行任何位置插值。物体在每次物理更新（`FixedUpdate()`）时位置会突然跳变，视觉上会有“抖动”或“跳跃”现象。
- **`Interpolate`**: Unity 会根据上一个和当前的物理帧位置进行插值，平滑渲染物体的位置。这是解决视觉抖动的最有效方法。
- **`Extrapolate`**: 根据当前速度预测下一帧位置，适用于速度快且稳定的物体，但预测失败时可能出错。

---

## 快速参考总结

| 问题 | 解决方案 | 关键设置 |
| :--- | :--- | :--- |
| **高速穿透** | 开启连续碰撞检测 | `Rigidbody` -> `Collision Detection` -> `Continuous` |
| **移动/碰撞抖动** | 1. 使用 `Rigidbody` 移动<br>2. 在 `FixedUpdate` 中操作<br>3. 开启位置插值 | 1. 使用 `rb.MovePosition` 或 `rb.velocity`<br>2. 将代码移至 `FixedUpdate`<br>3. `Rigidbody` -> `Interpolate` -> `Interpolate` |

遵循以上实践，可以有效解决大部分 Unity 中的物理移动和碰撞问题，让游戏表现更稳定。